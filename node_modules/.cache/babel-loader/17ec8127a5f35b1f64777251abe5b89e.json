{"ast":null,"code":"import { jsx as _jsx } from \"react/jsx-runtime\";\nimport { useCallback, useEffect, useReducer } from 'react';\nimport { useEthers, useLocalStorage } from '../../hooks';\nimport { useBlockNumber } from '../blockNumber';\nimport { useNotificationsContext } from '../notifications/context';\nimport { TransactionsContext } from './context';\nimport { DEFAULT_STORED_TRANSACTIONS } from './model';\nimport { transactionReducer } from './reducer';\nimport { useConfig } from '../config';\nexport function TransactionProvider(_ref) {\n  let {\n    children\n  } = _ref;\n  const {\n    chainId,\n    library\n  } = useEthers();\n  const blockNumber = useBlockNumber();\n  const {\n    localStorage\n  } = useConfig();\n  const [storage, setStorage] = useLocalStorage(localStorage.transactionPath);\n  const [transactions, dispatch] = useReducer(transactionReducer, storage !== null && storage !== void 0 ? storage : DEFAULT_STORED_TRANSACTIONS);\n  const {\n    addNotification\n  } = useNotificationsContext();\n  useEffect(() => {\n    setStorage(transactions);\n  }, [transactions]);\n  const addTransaction = useCallback(payload => {\n    dispatch({\n      type: 'ADD_TRANSACTION',\n      payload\n    });\n    addNotification({\n      notification: {\n        type: 'transactionStarted',\n        transaction: payload.transaction,\n        submittedAt: payload.submittedAt,\n        transactionName: payload.transactionName\n      },\n      chainId: payload.transaction.chainId\n    });\n  }, [dispatch]);\n  useEffect(() => {\n    const updateTransactions = async () => {\n      var _a;\n\n      if (!chainId || !library || !blockNumber) {\n        return;\n      }\n\n      const checkTransaction = async tx => {\n        if (tx.receipt || !shouldCheck(blockNumber, tx)) {\n          return tx;\n        }\n\n        try {\n          const receipt = await library.getTransactionReceipt(tx.transaction.hash);\n\n          if (receipt) {\n            const type = receipt.status === 0 ? 'transactionFailed' : 'transactionSucceed';\n            addNotification({\n              notification: {\n                type,\n                submittedAt: Date.now(),\n                transaction: tx.transaction,\n                receipt,\n                transactionName: tx.transactionName\n              },\n              chainId\n            });\n            return Object.assign(Object.assign({}, tx), {\n              receipt\n            });\n          } else {\n            return Object.assign(Object.assign({}, tx), {\n              lastCheckedBlockNumber: blockNumber\n            });\n          }\n        } catch (error) {\n          console.error(`failed to check transaction hash: ${tx.transaction.hash}`, error);\n        }\n\n        return tx;\n      };\n\n      const chainTransactions = (_a = transactions[chainId]) !== null && _a !== void 0 ? _a : [];\n      const newTransactions = [];\n\n      for (const tx of chainTransactions) {\n        const newTransaction = await checkTransaction(tx);\n        newTransactions.push(newTransaction);\n      }\n\n      dispatch({\n        type: 'UPDATE_TRANSACTIONS',\n        chainId,\n        transactions: newTransactions\n      });\n    };\n\n    updateTransactions();\n  }, [chainId, library, blockNumber]);\n  return _jsx(TransactionsContext.Provider, {\n    value: {\n      transactions,\n      addTransaction\n    },\n    children: children\n  }, void 0);\n}\n\nfunction shouldCheck(blockNumber, tx) {\n  if (tx.receipt) {\n    return false;\n  }\n\n  if (!tx.lastCheckedBlockNumber) {\n    return true;\n  }\n\n  const blocksSinceCheck = blockNumber - tx.lastCheckedBlockNumber;\n\n  if (blocksSinceCheck < 1) {\n    return false;\n  }\n\n  const minutesPending = (Date.now() - tx.submittedAt) / 1000 / 60;\n\n  if (minutesPending > 60) {\n    // every 10 blocks if pending for longer than an hour\n    return blocksSinceCheck > 9;\n  }\n\n  if (minutesPending > 5) {\n    // every 3 blocks if pending more than 5 minutes\n    return blocksSinceCheck > 2;\n  } // otherwise every block\n\n\n  return true;\n}","map":{"version":3,"mappings":"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","names":["useCallback","useEffect","useReducer","useEthers","useLocalStorage","useBlockNumber","useNotificationsContext","TransactionsContext","DEFAULT_STORED_TRANSACTIONS","transactionReducer","useConfig","TransactionProvider","children","chainId","library","blockNumber","localStorage","storage","setStorage","transactionPath","transactions","dispatch","addNotification","addTransaction","payload","type","notification","transaction","submittedAt","transactionName","updateTransactions","checkTransaction","tx","receipt","shouldCheck","getTransactionReceipt","hash","status","Date","now","lastCheckedBlockNumber","error","console","chainTransactions","_a","newTransactions","newTransaction","push","_jsx","Provider","value","blocksSinceCheck","minutesPending"],"sources":["/home/vukasin/Desktop/LuckySixFront/node_modules/@usedapp/core/src/providers/transactions/provider.tsx"],"sourcesContent":["import { ReactNode, useCallback, useEffect, useReducer } from 'react'\nimport { useEthers, useLocalStorage } from '../../hooks'\nimport { useBlockNumber } from '../blockNumber'\nimport { useNotificationsContext } from '../notifications/context'\nimport { TransactionsContext } from './context'\nimport { DEFAULT_STORED_TRANSACTIONS, StoredTransaction } from './model'\nimport { transactionReducer } from './reducer'\nimport { useConfig } from '../config'\n\ninterface Props {\n  children: ReactNode\n}\n\nexport function TransactionProvider({ children }: Props) {\n  const { chainId, library } = useEthers()\n  const blockNumber = useBlockNumber()\n  const { localStorage } = useConfig()\n  const [storage, setStorage] = useLocalStorage(localStorage.transactionPath)\n  const [transactions, dispatch] = useReducer(transactionReducer, storage ?? DEFAULT_STORED_TRANSACTIONS)\n  const { addNotification } = useNotificationsContext()\n\n  useEffect(() => {\n    setStorage(transactions)\n  }, [transactions])\n\n  const addTransaction = useCallback(\n    (payload: StoredTransaction) => {\n      dispatch({\n        type: 'ADD_TRANSACTION',\n        payload,\n      })\n      addNotification({\n        notification: {\n          type: 'transactionStarted',\n          transaction: payload.transaction,\n          submittedAt: payload.submittedAt,\n          transactionName: payload.transactionName,\n        },\n        chainId: payload.transaction.chainId,\n      })\n    },\n    [dispatch]\n  )\n\n  useEffect(() => {\n    const updateTransactions = async () => {\n      if (!chainId || !library || !blockNumber) {\n        return\n      }\n\n      const checkTransaction = async (tx: StoredTransaction) => {\n        if (tx.receipt || !shouldCheck(blockNumber, tx)) {\n          return tx\n        }\n\n        try {\n          const receipt = await library.getTransactionReceipt(tx.transaction.hash)\n          if (receipt) {\n            const type = receipt.status === 0 ? 'transactionFailed' : 'transactionSucceed'\n            addNotification({\n              notification: {\n                type,\n                submittedAt: Date.now(),\n                transaction: tx.transaction,\n                receipt,\n                transactionName: tx.transactionName,\n              },\n              chainId,\n            })\n\n            return { ...tx, receipt }\n          } else {\n            return { ...tx, lastCheckedBlockNumber: blockNumber }\n          }\n        } catch (error) {\n          console.error(`failed to check transaction hash: ${tx.transaction.hash}`, error)\n        }\n\n        return tx\n      }\n\n      const chainTransactions = transactions[chainId] ?? []\n      const newTransactions: StoredTransaction[] = []\n      for (const tx of chainTransactions) {\n        const newTransaction = await checkTransaction(tx)\n        newTransactions.push(newTransaction)\n      }\n\n      dispatch({ type: 'UPDATE_TRANSACTIONS', chainId, transactions: newTransactions })\n    }\n\n    updateTransactions()\n  }, [chainId, library, blockNumber])\n\n  return <TransactionsContext.Provider value={{ transactions, addTransaction }} children={children} />\n}\n\nfunction shouldCheck(blockNumber: number, tx: StoredTransaction): boolean {\n  if (tx.receipt) {\n    return false\n  }\n\n  if (!tx.lastCheckedBlockNumber) {\n    return true\n  }\n\n  const blocksSinceCheck = blockNumber - tx.lastCheckedBlockNumber\n  if (blocksSinceCheck < 1) {\n    return false\n  }\n\n  const minutesPending = (Date.now() - tx.submittedAt) / 1000 / 60\n  if (minutesPending > 60) {\n    // every 10 blocks if pending for longer than an hour\n    return blocksSinceCheck > 9\n  }\n\n  if (minutesPending > 5) {\n    // every 3 blocks if pending more than 5 minutes\n    return blocksSinceCheck > 2\n  }\n\n  // otherwise every block\n  return true\n}\n"]},"metadata":{},"sourceType":"module"}