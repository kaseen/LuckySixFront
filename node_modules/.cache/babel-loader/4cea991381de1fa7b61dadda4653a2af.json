{"ast":null,"code":"import { useMemo } from 'react';\nimport { useChainCalls } from './useChainCalls';\n\nfunction warnOnInvalidContractCall(call) {\n  console.warn(`Invalid contract call: address=${call && call.address} method=${call && call.method} args=${call && call.args}`);\n}\n\nfunction encodeCallData(call) {\n  if (!call) {\n    return undefined;\n  }\n\n  if (!call.address || !call.method) {\n    warnOnInvalidContractCall(call);\n    return undefined;\n  }\n\n  try {\n    return {\n      address: call.address,\n      data: call.abi.encodeFunctionData(call.method, call.args)\n    };\n  } catch (_a) {\n    warnOnInvalidContractCall(call);\n    return undefined;\n  }\n}\n\nexport function useContractCall(call) {\n  return useContractCalls([call])[0];\n}\nexport function useContractCalls(calls) {\n  const results = useChainCalls(calls.map(encodeCallData));\n  return useMemo(() => results.map((result, idx) => {\n    const call = calls[idx];\n\n    if (result === '0x') {\n      warnOnInvalidContractCall(call);\n      return undefined;\n    }\n\n    return call && result ? call.abi.decodeFunctionResult(call.method, result) : undefined;\n  }), [results]);\n}","map":{"version":3,"mappings":"AACA,SAASA,OAAT,QAAwB,OAAxB;AAEA,SAASC,aAAT,QAA8B,iBAA9B;;AAGA,SAASC,yBAAT,CAAmCC,IAAnC,EAA6D;AAC3DC,SAAO,CAACC,IAAR,CACE,kCAAkCF,IAAI,IAAIA,IAAI,CAACG,OAAO,WAAWH,IAAI,IAAIA,IAAI,CAACI,MAAM,SAASJ,IAAI,IAAIA,IAAI,CAACK,IAAI,EADhH;AAGD;;AAED,SAASC,cAAT,CAAwBN,IAAxB,EAAkD;AAChD,MAAI,CAACA,IAAL,EAAW;AACT,WAAOO,SAAP;AACD;;AACD,MAAI,CAACP,IAAI,CAACG,OAAN,IAAiB,CAACH,IAAI,CAACI,MAA3B,EAAmC;AACjCL,6BAAyB,CAACC,IAAD,CAAzB;AACA,WAAOO,SAAP;AACD;;AACD,MAAI;AACF,WAAO;AAAEJ,aAAO,EAAEH,IAAI,CAACG,OAAhB;AAAyBK,UAAI,EAAER,IAAI,CAACS,GAAL,CAASC,kBAAT,CAA4BV,IAAI,CAACI,MAAjC,EAAyCJ,IAAI,CAACK,IAA9C;AAA/B,KAAP;AACD,GAFD,CAEE,WAAM;AACNN,6BAAyB,CAACC,IAAD,CAAzB;AACA,WAAOO,SAAP;AACD;AACF;;AASD,OAAM,SAAUI,eAAV,CAA0BX,IAA1B,EAAoD;AACxD,SAAOY,gBAAgB,CAAC,CAACZ,IAAD,CAAD,CAAhB,CAAyB,CAAzB,CAAP;AACD;AAED,OAAM,SAAUY,gBAAV,CAA2BC,KAA3B,EAA0D;AAC9D,QAAMC,OAAO,GAAGhB,aAAa,CAACe,KAAK,CAACE,GAAN,CAAUT,cAAV,CAAD,CAA7B;AAEA,SAAOT,OAAO,CACZ,MACEiB,OAAO,CAACC,GAAR,CAAY,CAACC,MAAD,EAASC,GAAT,KAAgB;AAC1B,UAAMjB,IAAI,GAAGa,KAAK,CAACI,GAAD,CAAlB;;AACA,QAAID,MAAM,KAAK,IAAf,EAAqB;AACnBjB,+BAAyB,CAACC,IAAD,CAAzB;AACA,aAAOO,SAAP;AACD;;AACD,WAAOP,IAAI,IAAIgB,MAAR,GAAkBhB,IAAI,CAACS,GAAL,CAASS,oBAAT,CAA8BlB,IAAI,CAACI,MAAnC,EAA2CY,MAA3C,CAAlB,GAAiFT,SAAxF;AACD,GAPD,CAFU,EAUZ,CAACO,OAAD,CAVY,CAAd;AAYD","names":["useMemo","useChainCalls","warnOnInvalidContractCall","call","console","warn","address","method","args","encodeCallData","undefined","data","abi","encodeFunctionData","useContractCall","useContractCalls","calls","results","map","result","idx","decodeFunctionResult"],"sources":["/home/vukasin/Desktop/LuckySixFront/node_modules/@usedapp/core/src/hooks/useContractCall.ts"],"sourcesContent":["import { Interface } from '@ethersproject/abi'\nimport { useMemo } from 'react'\nimport { Falsy } from '../model/types'\nimport { useChainCalls } from './useChainCalls'\nimport { RawCall } from '../providers/chainState/callsReducer'\n\nfunction warnOnInvalidContractCall(call: ContractCall | Falsy) {\n  console.warn(\n    `Invalid contract call: address=${call && call.address} method=${call && call.method} args=${call && call.args}`\n  )\n}\n\nfunction encodeCallData(call: ContractCall | Falsy): RawCall | Falsy {\n  if (!call) {\n    return undefined\n  }\n  if (!call.address || !call.method) {\n    warnOnInvalidContractCall(call)\n    return undefined\n  }\n  try {\n    return { address: call.address, data: call.abi.encodeFunctionData(call.method, call.args) }\n  } catch {\n    warnOnInvalidContractCall(call)\n    return undefined\n  }\n}\n\nexport interface ContractCall {\n  abi: Interface\n  address: string\n  method: string\n  args: any[]\n}\n\nexport function useContractCall(call: ContractCall | Falsy): any[] | undefined {\n  return useContractCalls([call])[0]\n}\n\nexport function useContractCalls(calls: (ContractCall | Falsy)[]): (any[] | undefined)[] {\n  const results = useChainCalls(calls.map(encodeCallData))\n\n  return useMemo(\n    () =>\n      results.map((result, idx) => {\n        const call = calls[idx]\n        if (result === '0x') {\n          warnOnInvalidContractCall(call)\n          return undefined\n        }\n        return call && result ? (call.abi.decodeFunctionResult(call.method, result) as any[]) : undefined\n      }),\n    [results]\n  )\n}\n"]},"metadata":{},"sourceType":"module"}