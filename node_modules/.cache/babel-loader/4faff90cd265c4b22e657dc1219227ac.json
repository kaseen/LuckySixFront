{"ast":null,"code":"import { addressEqual } from '../../src';\nimport { useCallback, useState } from 'react';\nimport { useEthers } from './useEthers';\nimport { usePromiseTransaction } from './usePromiseTransaction';\nexport function connectContractToSigner(contract, options, library) {\n  if (contract.signer) {\n    return contract;\n  }\n\n  if (options === null || options === void 0 ? void 0 : options.signer) {\n    return contract.connect(options.signer);\n  }\n\n  if (library === null || library === void 0 ? void 0 : library.getSigner()) {\n    return contract.connect(library.getSigner());\n  }\n\n  throw new TypeError('No signer available in contract, options or library');\n}\nexport function useContractFunction(contract, functionName, options) {\n  const {\n    library,\n    chainId\n  } = useEthers();\n  const {\n    promiseTransaction,\n    state,\n    resetState\n  } = usePromiseTransaction(chainId, options);\n  const [events, setEvents] = useState(undefined);\n  const send = useCallback(async function () {\n    const contractWithSigner = connectContractToSigner(contract, options, library);\n    const receipt = await promiseTransaction(contractWithSigner[functionName](...arguments));\n\n    if (receipt === null || receipt === void 0 ? void 0 : receipt.logs) {\n      const events = receipt.logs.reduce((accumulatedLogs, log) => {\n        try {\n          return addressEqual(log.address, contract.address) ? [...accumulatedLogs, contract.interface.parseLog(log)] : accumulatedLogs;\n        } catch (_err) {\n          return accumulatedLogs;\n        }\n      }, []);\n      setEvents(events);\n    }\n  }, [contract, functionName, options, library]);\n  return {\n    send,\n    state,\n    events,\n    resetState\n  };\n}","map":{"version":3,"mappings":"AAAA,SAASA,YAAT,QAAiD,WAAjD;AAGA,SAASC,WAAT,EAAsBC,QAAtB,QAAsC,OAAtC;AACA,SAASC,SAAT,QAA0B,aAA1B;AACA,SAASC,qBAAT,QAAsC,yBAAtC;AAGA,OAAM,SAAUC,uBAAV,CAAkCC,QAAlC,EAAsDC,OAAtD,EAAoFC,OAApF,EAA6G;AACjH,MAAIF,QAAQ,CAACG,MAAb,EAAqB;AACnB,WAAOH,QAAP;AACD;;AAED,MAAIC,OAAO,SAAP,WAAO,WAAP,GAAO,MAAP,UAAO,CAAEE,MAAb,EAAqB;AACnB,WAAOH,QAAQ,CAACI,OAAT,CAAiBH,OAAO,CAACE,MAAzB,CAAP;AACD;;AAED,MAAID,OAAO,SAAP,WAAO,WAAP,GAAO,MAAP,UAAO,CAAEG,SAAT,EAAJ,EAA0B;AACxB,WAAOL,QAAQ,CAACI,OAAT,CAAiBF,OAAO,CAACG,SAAR,EAAjB,CAAP;AACD;;AAED,QAAM,IAAIC,SAAJ,CAAc,qDAAd,CAAN;AACD;AAED,OAAM,SAAUC,mBAAV,CAA8BP,QAA9B,EAAkDQ,YAAlD,EAAwEP,OAAxE,EAAoG;AACxG,QAAM;AAAEC,WAAF;AAAWO;AAAX,MAAuBZ,SAAS,EAAtC;AACA,QAAM;AAAEa,sBAAF;AAAsBC,SAAtB;AAA6BC;AAA7B,MAA4Cd,qBAAqB,CAACW,OAAD,EAAUR,OAAV,CAAvE;AACA,QAAM,CAACY,MAAD,EAASC,SAAT,IAAsBlB,QAAQ,CAA+BmB,SAA/B,CAApC;AAEA,QAAMC,IAAI,GAAGrB,WAAW,CACtB,kBAAyB;AACvB,UAAMsB,kBAAkB,GAAGlB,uBAAuB,CAACC,QAAD,EAAWC,OAAX,EAAoBC,OAApB,CAAlD;AACA,UAAMgB,OAAO,GAAG,MAAMR,kBAAkB,CAACO,kBAAkB,CAACT,YAAD,CAAlB,CAAiC,YAAjC,CAAD,CAAxC;;AACA,QAAIU,OAAO,SAAP,WAAO,WAAP,GAAO,MAAP,UAAO,CAAEC,IAAb,EAAmB;AACjB,YAAMN,MAAM,GAAGK,OAAO,CAACC,IAAR,CAAaC,MAAb,CAAoB,CAACC,eAAD,EAAkBC,GAAlB,KAAyB;AAC1D,YAAI;AACF,iBAAO5B,YAAY,CAAC4B,GAAG,CAACC,OAAL,EAAcvB,QAAQ,CAACuB,OAAvB,CAAZ,GACH,CAAC,GAAGF,eAAJ,EAAqBrB,QAAQ,CAACwB,SAAT,CAAmBC,QAAnB,CAA4BH,GAA5B,CAArB,CADG,GAEHD,eAFJ;AAGD,SAJD,CAIE,OAAOK,IAAP,EAAa;AACb,iBAAOL,eAAP;AACD;AACF,OARc,EAQZ,EARY,CAAf;AASAP,eAAS,CAACD,MAAD,CAAT;AACD;AACF,GAhBqB,EAiBtB,CAACb,QAAD,EAAWQ,YAAX,EAAyBP,OAAzB,EAAkCC,OAAlC,CAjBsB,CAAxB;AAoBA,SAAO;AAAEc,QAAF;AAAQL,SAAR;AAAeE,UAAf;AAAuBD;AAAvB,GAAP;AACD","names":["addressEqual","useCallback","useState","useEthers","usePromiseTransaction","connectContractToSigner","contract","options","library","signer","connect","getSigner","TypeError","useContractFunction","functionName","chainId","promiseTransaction","state","resetState","events","setEvents","undefined","send","contractWithSigner","receipt","logs","reduce","accumulatedLogs","log","address","interface","parseLog","_err"],"sources":["/home/vukasin/Desktop/LuckySixFront/node_modules/@usedapp/core/src/hooks/useContractFunction.ts"],"sourcesContent":["import { addressEqual, TransactionOptions } from '../../src'\nimport { Contract } from '@ethersproject/contracts'\nimport { JsonRpcProvider } from '@ethersproject/providers'\nimport { useCallback, useState } from 'react'\nimport { useEthers } from './useEthers'\nimport { usePromiseTransaction } from './usePromiseTransaction'\nimport { LogDescription } from 'ethers/lib/utils'\n\nexport function connectContractToSigner(contract: Contract, options?: TransactionOptions, library?: JsonRpcProvider) {\n  if (contract.signer) {\n    return contract\n  }\n\n  if (options?.signer) {\n    return contract.connect(options.signer)\n  }\n\n  if (library?.getSigner()) {\n    return contract.connect(library.getSigner())\n  }\n\n  throw new TypeError('No signer available in contract, options or library')\n}\n\nexport function useContractFunction(contract: Contract, functionName: string, options?: TransactionOptions) {\n  const { library, chainId } = useEthers()\n  const { promiseTransaction, state, resetState } = usePromiseTransaction(chainId, options)\n  const [events, setEvents] = useState<LogDescription[] | undefined>(undefined)\n\n  const send = useCallback(\n    async (...args: any[]) => {\n      const contractWithSigner = connectContractToSigner(contract, options, library)\n      const receipt = await promiseTransaction(contractWithSigner[functionName](...args))\n      if (receipt?.logs) {\n        const events = receipt.logs.reduce((accumulatedLogs, log) => {\n          try {\n            return addressEqual(log.address, contract.address)\n              ? [...accumulatedLogs, contract.interface.parseLog(log)]\n              : accumulatedLogs\n          } catch (_err) {\n            return accumulatedLogs\n          }\n        }, [] as LogDescription[])\n        setEvents(events)\n      }\n    },\n    [contract, functionName, options, library]\n  )\n\n  return { send, state, events, resetState }\n}\n"]},"metadata":{},"sourceType":"module"}