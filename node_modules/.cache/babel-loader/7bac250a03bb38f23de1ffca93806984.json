{"ast":null,"code":"import { utils } from 'ethers';\nimport { addressEqual } from './address';\nexport function warnOnInvalidCall(call) {\n  if (!call) {\n    return;\n  }\n\n  const {\n    contract,\n    method,\n    args\n  } = call;\n  console.warn(`Invalid contract call: address=${contract.address} method=${method} args=${args}`);\n}\nexport function encodeCallData(call) {\n  if (!call) {\n    return undefined;\n  }\n\n  const {\n    contract,\n    method,\n    args\n  } = call;\n\n  if (!contract.address || !method) {\n    warnOnInvalidCall(call);\n    return undefined;\n  }\n\n  try {\n    return {\n      address: contract.address,\n      data: contract.interface.encodeFunctionData(method, args)\n    };\n  } catch (_a) {\n    warnOnInvalidCall(call);\n    return undefined;\n  }\n}\nexport function getUniqueCalls(requests) {\n  const unique = [];\n\n  for (const request of requests) {\n    if (!unique.find(x => addressEqual(x.address, request.address) && x.data === request.data)) {\n      unique.push(request);\n    }\n  }\n\n  return unique;\n}\nexport function decodeCallResult(call, result) {\n  if (!result || !call) {\n    return undefined;\n  }\n\n  const {\n    value,\n    success\n  } = result;\n\n  try {\n    if (success) {\n      return {\n        value: call.contract.interface.decodeFunctionResult(call.method, value),\n        error: undefined\n      };\n    } else {\n      const errorMessage = new utils.Interface(['function Error(string)']).decodeFunctionData('Error', value)[0];\n      return {\n        value: undefined,\n        error: new Error(errorMessage)\n      };\n    }\n  } catch (error) {\n    return {\n      value: undefined,\n      error: error\n    };\n  }\n}","map":{"version":3,"mappings":"AAAA,SAASA,KAAT,QAAsB,QAAtB;AAIA,SAASC,YAAT,QAA6B,WAA7B;AAEA,OAAM,SAAUC,iBAAV,CAA4BC,IAA5B,EAA8C;AAClD,MAAI,CAACA,IAAL,EAAW;AACT;AACD;;AACD,QAAM;AAAEC,YAAF;AAAYC,UAAZ;AAAoBC;AAApB,MAA6BH,IAAnC;AACAI,SAAO,CAACC,IAAR,CAAa,kCAAkCJ,QAAQ,CAACK,OAAO,WAAWJ,MAAM,SAASC,IAAI,EAA7F;AACD;AAED,OAAM,SAAUI,cAAV,CAAyBP,IAAzB,EAA2C;AAC/C,MAAI,CAACA,IAAL,EAAW;AACT,WAAOQ,SAAP;AACD;;AACD,QAAM;AAAEP,YAAF;AAAYC,UAAZ;AAAoBC;AAApB,MAA6BH,IAAnC;;AACA,MAAI,CAACC,QAAQ,CAACK,OAAV,IAAqB,CAACJ,MAA1B,EAAkC;AAChCH,qBAAiB,CAACC,IAAD,CAAjB;AACA,WAAOQ,SAAP;AACD;;AACD,MAAI;AACF,WAAO;AAAEF,aAAO,EAAEL,QAAQ,CAACK,OAApB;AAA6BG,UAAI,EAAER,QAAQ,CAACS,SAAT,CAAmBC,kBAAnB,CAAsCT,MAAtC,EAA8CC,IAA9C;AAAnC,KAAP;AACD,GAFD,CAEE,WAAM;AACNJ,qBAAiB,CAACC,IAAD,CAAjB;AACA,WAAOQ,SAAP;AACD;AACF;AAED,OAAM,SAAUI,cAAV,CAAyBC,QAAzB,EAA4C;AAChD,QAAMC,MAAM,GAAc,EAA1B;;AACA,OAAK,MAAMC,OAAX,IAAsBF,QAAtB,EAAgC;AAC9B,QAAI,CAACC,MAAM,CAACE,IAAP,CAAaC,CAAD,IAAOnB,YAAY,CAACmB,CAAC,CAACX,OAAH,EAAYS,OAAO,CAACT,OAApB,CAAZ,IAA4CW,CAAC,CAACR,IAAF,KAAWM,OAAO,CAACN,IAAlF,CAAL,EAA8F;AAC5FK,YAAM,CAACI,IAAP,CAAYH,OAAZ;AACD;AACF;;AACD,SAAOD,MAAP;AACD;AAID,OAAM,SAAUK,gBAAV,CAA2BnB,IAA3B,EAA+CoB,MAA/C,EAAoE;AACxE,MAAI,CAACA,MAAD,IAAW,CAACpB,IAAhB,EAAsB;AACpB,WAAOQ,SAAP;AACD;;AACD,QAAM;AAAEa,SAAF;AAASC;AAAT,MAAqBF,MAA3B;;AACA,MAAI;AACF,QAAIE,OAAJ,EAAa;AACX,aAAO;AACLD,aAAK,EAAErB,IAAI,CAACC,QAAL,CAAcS,SAAd,CAAwBa,oBAAxB,CAA6CvB,IAAI,CAACE,MAAlD,EAA0DmB,KAA1D,CADF;AAELG,aAAK,EAAEhB;AAFF,OAAP;AAID,KALD,MAKO;AACL,YAAMiB,YAAY,GAAW,IAAI5B,KAAK,CAAC6B,SAAV,CAAoB,CAAC,wBAAD,CAApB,EAAgDC,kBAAhD,CAAmE,OAAnE,EAA4EN,KAA5E,EAAmF,CAAnF,CAA7B;AACA,aAAO;AACLA,aAAK,EAAEb,SADF;AAELgB,aAAK,EAAE,IAAII,KAAJ,CAAUH,YAAV;AAFF,OAAP;AAID;AACF,GAbD,CAaE,OAAOD,KAAP,EAAc;AACd,WAAO;AACLH,WAAK,EAAEb,SADF;AAELgB,WAAK,EAAEA;AAFF,KAAP;AAID;AACF","names":["utils","addressEqual","warnOnInvalidCall","call","contract","method","args","console","warn","address","encodeCallData","undefined","data","interface","encodeFunctionData","getUniqueCalls","requests","unique","request","find","x","push","decodeCallResult","result","value","success","decodeFunctionResult","error","errorMessage","Interface","decodeFunctionData","Error"],"sources":["/home/vukasin/Desktop/LuckySixFront/node_modules/@usedapp/core/src/helpers/calls.ts"],"sourcesContent":["import { utils } from 'ethers'\nimport { Call } from '../hooks/useCall'\nimport { Falsy } from '../model/types'\nimport { RawCall, RawCallResult } from '../providers'\nimport { addressEqual } from './address'\n\nexport function warnOnInvalidCall(call: Call | Falsy) {\n  if (!call) {\n    return\n  }\n  const { contract, method, args } = call\n  console.warn(`Invalid contract call: address=${contract.address} method=${method} args=${args}`)\n}\n\nexport function encodeCallData(call: Call | Falsy): RawCall | Falsy {\n  if (!call) {\n    return undefined\n  }\n  const { contract, method, args } = call\n  if (!contract.address || !method) {\n    warnOnInvalidCall(call)\n    return undefined\n  }\n  try {\n    return { address: contract.address, data: contract.interface.encodeFunctionData(method, args) }\n  } catch {\n    warnOnInvalidCall(call)\n    return undefined\n  }\n}\n\nexport function getUniqueCalls(requests: RawCall[]) {\n  const unique: RawCall[] = []\n  for (const request of requests) {\n    if (!unique.find((x) => addressEqual(x.address, request.address) && x.data === request.data)) {\n      unique.push(request)\n    }\n  }\n  return unique\n}\n\nexport type CallResult = { value: any[]; error: undefined } | { value: undefined; error: Error } | undefined\n\nexport function decodeCallResult(call: Call | Falsy, result: RawCallResult): CallResult {\n  if (!result || !call) {\n    return undefined\n  }\n  const { value, success } = result\n  try {\n    if (success) {\n      return {\n        value: call.contract.interface.decodeFunctionResult(call.method, value) as any[],\n        error: undefined,\n      }\n    } else {\n      const errorMessage: string = new utils.Interface(['function Error(string)']).decodeFunctionData('Error', value)[0]\n      return {\n        value: undefined,\n        error: new Error(errorMessage),\n      }\n    }\n  } catch (error) {\n    return {\n      value: undefined,\n      error: error as Error,\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}