{"ast":null,"code":"\"use strict\";\n\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n;\nconst _constructorGuard = {};\nlet ModifiersBytes = {\n  calldata: true,\n  memory: true,\n  storage: true\n};\nlet ModifiersNest = {\n  calldata: true,\n  memory: true\n};\n\nfunction checkModifier(type, name) {\n  if (type === \"bytes\" || type === \"string\") {\n    if (ModifiersBytes[name]) {\n      return true;\n    }\n  } else if (type === \"address\") {\n    if (name === \"payable\") {\n      return true;\n    }\n  } else if (type.indexOf(\"[\") >= 0 || type === \"tuple\") {\n    if (ModifiersNest[name]) {\n      return true;\n    }\n  }\n\n  if (ModifiersBytes[name] || name === \"payable\") {\n    logger.throwArgumentError(\"invalid modifier\", \"name\", name);\n  }\n\n  return false;\n} // @TODO: Make sure that children of an indexed tuple are marked with a null indexed\n\n\nfunction parseParamType(param, allowIndexed) {\n  let originalParam = param;\n\n  function throwError(i) {\n    logger.throwArgumentError(`unexpected character at position ${i}`, \"param\", param);\n  }\n\n  param = param.replace(/\\s/g, \" \");\n\n  function newNode(parent) {\n    let node = {\n      type: \"\",\n      name: \"\",\n      parent: parent,\n      state: {\n        allowType: true\n      }\n    };\n\n    if (allowIndexed) {\n      node.indexed = false;\n    }\n\n    return node;\n  }\n\n  let parent = {\n    type: \"\",\n    name: \"\",\n    state: {\n      allowType: true\n    }\n  };\n  let node = parent;\n\n  for (let i = 0; i < param.length; i++) {\n    let c = param[i];\n\n    switch (c) {\n      case \"(\":\n        if (node.state.allowType && node.type === \"\") {\n          node.type = \"tuple\";\n        } else if (!node.state.allowParams) {\n          throwError(i);\n        }\n\n        node.state.allowType = false;\n        node.type = verifyType(node.type);\n        node.components = [newNode(node)];\n        node = node.components[0];\n        break;\n\n      case \")\":\n        delete node.state;\n\n        if (node.name === \"indexed\") {\n          if (!allowIndexed) {\n            throwError(i);\n          }\n\n          node.indexed = true;\n          node.name = \"\";\n        }\n\n        if (checkModifier(node.type, node.name)) {\n          node.name = \"\";\n        }\n\n        node.type = verifyType(node.type);\n        let child = node;\n        node = node.parent;\n\n        if (!node) {\n          throwError(i);\n        }\n\n        delete child.parent;\n        node.state.allowParams = false;\n        node.state.allowName = true;\n        node.state.allowArray = true;\n        break;\n\n      case \",\":\n        delete node.state;\n\n        if (node.name === \"indexed\") {\n          if (!allowIndexed) {\n            throwError(i);\n          }\n\n          node.indexed = true;\n          node.name = \"\";\n        }\n\n        if (checkModifier(node.type, node.name)) {\n          node.name = \"\";\n        }\n\n        node.type = verifyType(node.type);\n        let sibling = newNode(node.parent); //{ type: \"\", name: \"\", parent: node.parent, state: { allowType: true } };\n\n        node.parent.components.push(sibling);\n        delete node.parent;\n        node = sibling;\n        break;\n      // Hit a space...\n\n      case \" \":\n        // If reading type, the type is done and may read a param or name\n        if (node.state.allowType) {\n          if (node.type !== \"\") {\n            node.type = verifyType(node.type);\n            delete node.state.allowType;\n            node.state.allowName = true;\n            node.state.allowParams = true;\n          }\n        } // If reading name, the name is done\n\n\n        if (node.state.allowName) {\n          if (node.name !== \"\") {\n            if (node.name === \"indexed\") {\n              if (!allowIndexed) {\n                throwError(i);\n              }\n\n              if (node.indexed) {\n                throwError(i);\n              }\n\n              node.indexed = true;\n              node.name = \"\";\n            } else if (checkModifier(node.type, node.name)) {\n              node.name = \"\";\n            } else {\n              node.state.allowName = false;\n            }\n          }\n        }\n\n        break;\n\n      case \"[\":\n        if (!node.state.allowArray) {\n          throwError(i);\n        }\n\n        node.type += c;\n        node.state.allowArray = false;\n        node.state.allowName = false;\n        node.state.readArray = true;\n        break;\n\n      case \"]\":\n        if (!node.state.readArray) {\n          throwError(i);\n        }\n\n        node.type += c;\n        node.state.readArray = false;\n        node.state.allowArray = true;\n        node.state.allowName = true;\n        break;\n\n      default:\n        if (node.state.allowType) {\n          node.type += c;\n          node.state.allowParams = true;\n          node.state.allowArray = true;\n        } else if (node.state.allowName) {\n          node.name += c;\n          delete node.state.allowArray;\n        } else if (node.state.readArray) {\n          node.type += c;\n        } else {\n          throwError(i);\n        }\n\n    }\n  }\n\n  if (node.parent) {\n    logger.throwArgumentError(\"unexpected eof\", \"param\", param);\n  }\n\n  delete parent.state;\n\n  if (node.name === \"indexed\") {\n    if (!allowIndexed) {\n      throwError(originalParam.length - 7);\n    }\n\n    if (node.indexed) {\n      throwError(originalParam.length - 7);\n    }\n\n    node.indexed = true;\n    node.name = \"\";\n  } else if (checkModifier(node.type, node.name)) {\n    node.name = \"\";\n  }\n\n  parent.type = verifyType(parent.type);\n  return parent;\n}\n\nfunction populate(object, params) {\n  for (let key in params) {\n    defineReadOnly(object, key, params[key]);\n  }\n}\n\nexport const FormatTypes = Object.freeze({\n  // Bare formatting, as is needed for computing a sighash of an event or function\n  sighash: \"sighash\",\n  // Human-Readable with Minimal spacing and without names (compact human-readable)\n  minimal: \"minimal\",\n  // Human-Readble with nice spacing, including all names\n  full: \"full\",\n  // JSON-format a la Solidity\n  json: \"json\"\n});\nconst paramTypeArray = new RegExp(/^(.*)\\[([0-9]*)\\]$/);\nexport class ParamType {\n  constructor(constructorGuard, params) {\n    if (constructorGuard !== _constructorGuard) {\n      logger.throwError(\"use fromString\", Logger.errors.UNSUPPORTED_OPERATION, {\n        operation: \"new ParamType()\"\n      });\n    }\n\n    populate(this, params);\n    let match = this.type.match(paramTypeArray);\n\n    if (match) {\n      populate(this, {\n        arrayLength: parseInt(match[2] || \"-1\"),\n        arrayChildren: ParamType.fromObject({\n          type: match[1],\n          components: this.components\n        }),\n        baseType: \"array\"\n      });\n    } else {\n      populate(this, {\n        arrayLength: null,\n        arrayChildren: null,\n        baseType: this.components != null ? \"tuple\" : this.type\n      });\n    }\n\n    this._isParamType = true;\n    Object.freeze(this);\n  } // Format the parameter fragment\n  //   - sighash: \"(uint256,address)\"\n  //   - minimal: \"tuple(uint256,address) indexed\"\n  //   - full:    \"tuple(uint256 foo, addres bar) indexed baz\"\n\n\n  format(format) {\n    if (!format) {\n      format = FormatTypes.sighash;\n    }\n\n    if (!FormatTypes[format]) {\n      logger.throwArgumentError(\"invalid format type\", \"format\", format);\n    }\n\n    if (format === FormatTypes.json) {\n      let result = {\n        type: this.baseType === \"tuple\" ? \"tuple\" : this.type,\n        name: this.name || undefined\n      };\n\n      if (typeof this.indexed === \"boolean\") {\n        result.indexed = this.indexed;\n      }\n\n      if (this.components) {\n        result.components = this.components.map(comp => JSON.parse(comp.format(format)));\n      }\n\n      return JSON.stringify(result);\n    }\n\n    let result = \"\"; // Array\n\n    if (this.baseType === \"array\") {\n      result += this.arrayChildren.format(format);\n      result += \"[\" + (this.arrayLength < 0 ? \"\" : String(this.arrayLength)) + \"]\";\n    } else {\n      if (this.baseType === \"tuple\") {\n        if (format !== FormatTypes.sighash) {\n          result += this.type;\n        }\n\n        result += \"(\" + this.components.map(comp => comp.format(format)).join(format === FormatTypes.full ? \", \" : \",\") + \")\";\n      } else {\n        result += this.type;\n      }\n    }\n\n    if (format !== FormatTypes.sighash) {\n      if (this.indexed === true) {\n        result += \" indexed\";\n      }\n\n      if (format === FormatTypes.full && this.name) {\n        result += \" \" + this.name;\n      }\n    }\n\n    return result;\n  }\n\n  static from(value, allowIndexed) {\n    if (typeof value === \"string\") {\n      return ParamType.fromString(value, allowIndexed);\n    }\n\n    return ParamType.fromObject(value);\n  }\n\n  static fromObject(value) {\n    if (ParamType.isParamType(value)) {\n      return value;\n    }\n\n    return new ParamType(_constructorGuard, {\n      name: value.name || null,\n      type: verifyType(value.type),\n      indexed: value.indexed == null ? null : !!value.indexed,\n      components: value.components ? value.components.map(ParamType.fromObject) : null\n    });\n  }\n\n  static fromString(value, allowIndexed) {\n    function ParamTypify(node) {\n      return ParamType.fromObject({\n        name: node.name,\n        type: node.type,\n        indexed: node.indexed,\n        components: node.components\n      });\n    }\n\n    return ParamTypify(parseParamType(value, !!allowIndexed));\n  }\n\n  static isParamType(value) {\n    return !!(value != null && value._isParamType);\n  }\n\n}\n;\n\nfunction parseParams(value, allowIndex) {\n  return splitNesting(value).map(param => ParamType.fromString(param, allowIndex));\n}\n\nexport class Fragment {\n  constructor(constructorGuard, params) {\n    if (constructorGuard !== _constructorGuard) {\n      logger.throwError(\"use a static from method\", Logger.errors.UNSUPPORTED_OPERATION, {\n        operation: \"new Fragment()\"\n      });\n    }\n\n    populate(this, params);\n    this._isFragment = true;\n    Object.freeze(this);\n  }\n\n  static from(value) {\n    if (Fragment.isFragment(value)) {\n      return value;\n    }\n\n    if (typeof value === \"string\") {\n      return Fragment.fromString(value);\n    }\n\n    return Fragment.fromObject(value);\n  }\n\n  static fromObject(value) {\n    if (Fragment.isFragment(value)) {\n      return value;\n    }\n\n    switch (value.type) {\n      case \"function\":\n        return FunctionFragment.fromObject(value);\n\n      case \"event\":\n        return EventFragment.fromObject(value);\n\n      case \"constructor\":\n        return ConstructorFragment.fromObject(value);\n\n      case \"fallback\":\n      case \"receive\":\n        // @TODO: Something? Maybe return a FunctionFragment? A custom DefaultFunctionFragment?\n        return null;\n    }\n\n    return logger.throwArgumentError(\"invalid fragment object\", \"value\", value);\n  }\n\n  static fromString(value) {\n    // Make sure the \"returns\" is surrounded by a space and all whitespace is exactly one space\n    value = value.replace(/\\s/g, \" \");\n    value = value.replace(/\\(/g, \" (\").replace(/\\)/g, \") \").replace(/\\s+/g, \" \");\n    value = value.trim();\n\n    if (value.split(\" \")[0] === \"event\") {\n      return EventFragment.fromString(value.substring(5).trim());\n    } else if (value.split(\" \")[0] === \"function\") {\n      return FunctionFragment.fromString(value.substring(8).trim());\n    } else if (value.split(\"(\")[0].trim() === \"constructor\") {\n      return ConstructorFragment.fromString(value.trim());\n    }\n\n    return logger.throwArgumentError(\"unsupported fragment\", \"value\", value);\n  }\n\n  static isFragment(value) {\n    return !!(value && value._isFragment);\n  }\n\n}\nexport class EventFragment extends Fragment {\n  format(format) {\n    if (!format) {\n      format = FormatTypes.sighash;\n    }\n\n    if (!FormatTypes[format]) {\n      logger.throwArgumentError(\"invalid format type\", \"format\", format);\n    }\n\n    if (format === FormatTypes.json) {\n      return JSON.stringify({\n        type: \"event\",\n        anonymous: this.anonymous,\n        name: this.name,\n        inputs: this.inputs.map(input => JSON.parse(input.format(format)))\n      });\n    }\n\n    let result = \"\";\n\n    if (format !== FormatTypes.sighash) {\n      result += \"event \";\n    }\n\n    result += this.name + \"(\" + this.inputs.map(input => input.format(format)).join(format === FormatTypes.full ? \", \" : \",\") + \") \";\n\n    if (format !== FormatTypes.sighash) {\n      if (this.anonymous) {\n        result += \"anonymous \";\n      }\n    }\n\n    return result.trim();\n  }\n\n  static from(value) {\n    if (typeof value === \"string\") {\n      return EventFragment.fromString(value);\n    }\n\n    return EventFragment.fromObject(value);\n  }\n\n  static fromObject(value) {\n    if (EventFragment.isEventFragment(value)) {\n      return value;\n    }\n\n    if (value.type !== \"event\") {\n      logger.throwArgumentError(\"invalid event object\", \"value\", value);\n    }\n\n    const params = {\n      name: verifyIdentifier(value.name),\n      anonymous: value.anonymous,\n      inputs: value.inputs ? value.inputs.map(ParamType.fromObject) : [],\n      type: \"event\"\n    };\n    return new EventFragment(_constructorGuard, params);\n  }\n\n  static fromString(value) {\n    let match = value.match(regexParen);\n\n    if (!match) {\n      logger.throwArgumentError(\"invalid event string\", \"value\", value);\n    }\n\n    let anonymous = false;\n    match[3].split(\" \").forEach(modifier => {\n      switch (modifier.trim()) {\n        case \"anonymous\":\n          anonymous = true;\n          break;\n\n        case \"\":\n          break;\n\n        default:\n          logger.warn(\"unknown modifier: \" + modifier);\n      }\n    });\n    return EventFragment.fromObject({\n      name: match[1].trim(),\n      anonymous: anonymous,\n      inputs: parseParams(match[2], true),\n      type: \"event\"\n    });\n  }\n\n  static isEventFragment(value) {\n    return value && value._isFragment && value.type === \"event\";\n  }\n\n}\n\nfunction parseGas(value, params) {\n  params.gas = null;\n  let comps = value.split(\"@\");\n\n  if (comps.length !== 1) {\n    if (comps.length > 2) {\n      logger.throwArgumentError(\"invalid human-readable ABI signature\", \"value\", value);\n    }\n\n    if (!comps[1].match(/^[0-9]+$/)) {\n      logger.throwArgumentError(\"invalid human-readable ABI signature gas\", \"value\", value);\n    }\n\n    params.gas = BigNumber.from(comps[1]);\n    return comps[0];\n  }\n\n  return value;\n}\n\nfunction parseModifiers(value, params) {\n  params.constant = false;\n  params.payable = false;\n  params.stateMutability = \"nonpayable\";\n  value.split(\" \").forEach(modifier => {\n    switch (modifier.trim()) {\n      case \"constant\":\n        params.constant = true;\n        break;\n\n      case \"payable\":\n        params.payable = true;\n        params.stateMutability = \"payable\";\n        break;\n\n      case \"nonpayable\":\n        params.payable = false;\n        params.stateMutability = \"nonpayable\";\n        break;\n\n      case \"pure\":\n        params.constant = true;\n        params.stateMutability = \"pure\";\n        break;\n\n      case \"view\":\n        params.constant = true;\n        params.stateMutability = \"view\";\n        break;\n\n      case \"external\":\n      case \"public\":\n      case \"\":\n        break;\n\n      default:\n        console.log(\"unknown modifier: \" + modifier);\n    }\n  });\n}\n\nfunction verifyState(value) {\n  let result = {\n    constant: false,\n    payable: true,\n    stateMutability: \"payable\"\n  };\n\n  if (value.stateMutability != null) {\n    result.stateMutability = value.stateMutability; // Set (and check things are consistent) the constant property\n\n    result.constant = result.stateMutability === \"view\" || result.stateMutability === \"pure\";\n\n    if (value.constant != null) {\n      if (!!value.constant !== result.constant) {\n        logger.throwArgumentError(\"cannot have constant function with mutability \" + result.stateMutability, \"value\", value);\n      }\n    } // Set (and check things are consistent) the payable property\n\n\n    result.payable = result.stateMutability === \"payable\";\n\n    if (value.payable != null) {\n      if (!!value.payable !== result.payable) {\n        logger.throwArgumentError(\"cannot have payable function with mutability \" + result.stateMutability, \"value\", value);\n      }\n    }\n  } else if (value.payable != null) {\n    result.payable = !!value.payable; // If payable we can assume non-constant; otherwise we can't assume\n\n    if (value.constant == null && !result.payable && value.type !== \"constructor\") {\n      logger.throwArgumentError(\"unable to determine stateMutability\", \"value\", value);\n    }\n\n    result.constant = !!value.constant;\n\n    if (result.constant) {\n      result.stateMutability = \"view\";\n    } else {\n      result.stateMutability = result.payable ? \"payable\" : \"nonpayable\";\n    }\n\n    if (result.payable && result.constant) {\n      logger.throwArgumentError(\"cannot have constant payable function\", \"value\", value);\n    }\n  } else if (value.constant != null) {\n    result.constant = !!value.constant;\n    result.payable = !result.constant;\n    result.stateMutability = result.constant ? \"view\" : \"payable\";\n  } else if (value.type !== \"constructor\") {\n    logger.throwArgumentError(\"unable to determine stateMutability\", \"value\", value);\n  }\n\n  return result;\n}\n\nexport class ConstructorFragment extends Fragment {\n  format(format) {\n    if (!format) {\n      format = FormatTypes.sighash;\n    }\n\n    if (!FormatTypes[format]) {\n      logger.throwArgumentError(\"invalid format type\", \"format\", format);\n    }\n\n    if (format === FormatTypes.json) {\n      return JSON.stringify({\n        type: \"constructor\",\n        stateMutability: this.stateMutability !== \"nonpayable\" ? this.stateMutability : undefined,\n        payble: this.payable,\n        gas: this.gas ? this.gas.toNumber() : undefined,\n        inputs: this.inputs.map(input => JSON.parse(input.format(format)))\n      });\n    }\n\n    if (format === FormatTypes.sighash) {\n      logger.throwError(\"cannot format a constructor for sighash\", Logger.errors.UNSUPPORTED_OPERATION, {\n        operation: \"format(sighash)\"\n      });\n    }\n\n    let result = \"constructor(\" + this.inputs.map(input => input.format(format)).join(format === FormatTypes.full ? \", \" : \",\") + \") \";\n\n    if (this.stateMutability && this.stateMutability !== \"nonpayable\") {\n      result += this.stateMutability + \" \";\n    }\n\n    return result.trim();\n  }\n\n  static from(value) {\n    if (typeof value === \"string\") {\n      return ConstructorFragment.fromString(value);\n    }\n\n    return ConstructorFragment.fromObject(value);\n  }\n\n  static fromObject(value) {\n    if (ConstructorFragment.isConstructorFragment(value)) {\n      return value;\n    }\n\n    if (value.type !== \"constructor\") {\n      logger.throwArgumentError(\"invalid constructor object\", \"value\", value);\n    }\n\n    let state = verifyState(value);\n\n    if (state.constant) {\n      logger.throwArgumentError(\"constructor cannot be constant\", \"value\", value);\n    }\n\n    const params = {\n      name: null,\n      type: value.type,\n      inputs: value.inputs ? value.inputs.map(ParamType.fromObject) : [],\n      payable: state.payable,\n      stateMutability: state.stateMutability,\n      gas: value.gas ? BigNumber.from(value.gas) : null\n    };\n    return new ConstructorFragment(_constructorGuard, params);\n  }\n\n  static fromString(value) {\n    let params = {\n      type: \"constructor\"\n    };\n    value = parseGas(value, params);\n    let parens = value.match(regexParen);\n\n    if (!parens || parens[1].trim() !== \"constructor\") {\n      logger.throwArgumentError(\"invalid constructor string\", \"value\", value);\n    }\n\n    params.inputs = parseParams(parens[2].trim(), false);\n    parseModifiers(parens[3].trim(), params);\n    return ConstructorFragment.fromObject(params);\n  }\n\n  static isConstructorFragment(value) {\n    return value && value._isFragment && value.type === \"constructor\";\n  }\n\n}\nexport class FunctionFragment extends ConstructorFragment {\n  format(format) {\n    if (!format) {\n      format = FormatTypes.sighash;\n    }\n\n    if (!FormatTypes[format]) {\n      logger.throwArgumentError(\"invalid format type\", \"format\", format);\n    }\n\n    if (format === FormatTypes.json) {\n      return JSON.stringify({\n        type: \"function\",\n        name: this.name,\n        constant: this.constant,\n        stateMutability: this.stateMutability !== \"nonpayable\" ? this.stateMutability : undefined,\n        payble: this.payable,\n        gas: this.gas ? this.gas.toNumber() : undefined,\n        inputs: this.inputs.map(input => JSON.parse(input.format(format))),\n        ouputs: this.outputs.map(output => JSON.parse(output.format(format)))\n      });\n    }\n\n    let result = \"\";\n\n    if (format !== FormatTypes.sighash) {\n      result += \"function \";\n    }\n\n    result += this.name + \"(\" + this.inputs.map(input => input.format(format)).join(format === FormatTypes.full ? \", \" : \",\") + \") \";\n\n    if (format !== FormatTypes.sighash) {\n      if (this.stateMutability) {\n        if (this.stateMutability !== \"nonpayable\") {\n          result += this.stateMutability + \" \";\n        }\n      } else if (this.constant) {\n        result += \"view \";\n      }\n\n      if (this.outputs && this.outputs.length) {\n        result += \"returns (\" + this.outputs.map(output => output.format(format)).join(\", \") + \") \";\n      }\n\n      if (this.gas != null) {\n        result += \"@\" + this.gas.toString() + \" \";\n      }\n    }\n\n    return result.trim();\n  }\n\n  static from(value) {\n    if (typeof value === \"string\") {\n      return FunctionFragment.fromString(value);\n    }\n\n    return FunctionFragment.fromObject(value);\n  }\n\n  static fromObject(value) {\n    if (FunctionFragment.isFunctionFragment(value)) {\n      return value;\n    }\n\n    if (value.type !== \"function\") {\n      logger.throwArgumentError(\"invalid function object\", \"value\", value);\n    }\n\n    let state = verifyState(value);\n    const params = {\n      type: value.type,\n      name: verifyIdentifier(value.name),\n      constant: state.constant,\n      inputs: value.inputs ? value.inputs.map(ParamType.fromObject) : [],\n      outputs: value.outputs ? value.outputs.map(ParamType.fromObject) : [],\n      payable: state.payable,\n      stateMutability: state.stateMutability,\n      gas: value.gas ? BigNumber.from(value.gas) : null\n    };\n    return new FunctionFragment(_constructorGuard, params);\n  }\n\n  static fromString(value) {\n    let params = {\n      type: \"function\"\n    };\n    value = parseGas(value, params);\n    let comps = value.split(\" returns \");\n\n    if (comps.length > 2) {\n      logger.throwArgumentError(\"invalid function string\", \"value\", value);\n    }\n\n    let parens = comps[0].match(regexParen);\n\n    if (!parens) {\n      logger.throwArgumentError(\"invalid function signature\", \"value\", value);\n    }\n\n    params.name = parens[1].trim();\n\n    if (params.name) {\n      verifyIdentifier(params.name);\n    }\n\n    params.inputs = parseParams(parens[2], false);\n    parseModifiers(parens[3].trim(), params); // We have outputs\n\n    if (comps.length > 1) {\n      let returns = comps[1].match(regexParen);\n\n      if (returns[1].trim() != \"\" || returns[3].trim() != \"\") {\n        logger.throwArgumentError(\"unexpected tokens\", \"value\", value);\n      }\n\n      params.outputs = parseParams(returns[2], false);\n    } else {\n      params.outputs = [];\n    }\n\n    return FunctionFragment.fromObject(params);\n  }\n\n  static isFunctionFragment(value) {\n    return value && value._isFragment && value.type === \"function\";\n  }\n\n} //export class ErrorFragment extends Fragment {\n//}\n//export class StructFragment extends Fragment {\n//}\n\nfunction verifyType(type) {\n  // These need to be transformed to their full description\n  if (type.match(/^uint($|[^1-9])/)) {\n    type = \"uint256\" + type.substring(4);\n  } else if (type.match(/^int($|[^1-9])/)) {\n    type = \"int256\" + type.substring(3);\n  } // @TODO: more verification\n\n\n  return type;\n}\n\nconst regexIdentifier = new RegExp(\"^[A-Za-z_][A-Za-z0-9_]*$\");\n\nfunction verifyIdentifier(value) {\n  if (!value || !value.match(regexIdentifier)) {\n    logger.throwArgumentError(`invalid identifier \"${value}\"`, \"value\", value);\n  }\n\n  return value;\n}\n\nconst regexParen = new RegExp(\"^([^)(]*)\\\\((.*)\\\\)([^)(]*)$\");\n\nfunction splitNesting(value) {\n  value = value.trim();\n  let result = [];\n  let accum = \"\";\n  let depth = 0;\n\n  for (let offset = 0; offset < value.length; offset++) {\n    let c = value[offset];\n\n    if (c === \",\" && depth === 0) {\n      result.push(accum);\n      accum = \"\";\n    } else {\n      accum += c;\n\n      if (c === \"(\") {\n        depth++;\n      } else if (c === \")\") {\n        depth--;\n\n        if (depth === -1) {\n          logger.throwArgumentError(\"unbalanced parenthesis\", \"value\", value);\n        }\n      }\n    }\n  }\n\n  if (accum) {\n    result.push(accum);\n  }\n\n  return result;\n}","map":{"version":3,"mappings":"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","names":["BigNumber","defineReadOnly","Logger","version","logger","_constructorGuard","ModifiersBytes","calldata","memory","storage","ModifiersNest","checkModifier","type","name","indexOf","throwArgumentError","parseParamType","param","allowIndexed","originalParam","throwError","i","replace","newNode","parent","node","state","allowType","indexed","length","c","allowParams","verifyType","components","child","allowName","allowArray","sibling","push","readArray","populate","object","params","key","FormatTypes","Object","freeze","sighash","minimal","full","json","paramTypeArray","RegExp","ParamType","constructor","constructorGuard","errors","UNSUPPORTED_OPERATION","operation","match","arrayLength","parseInt","arrayChildren","fromObject","baseType","_isParamType","format","result","undefined","map","comp","JSON","parse","stringify","String","join","from","value","fromString","isParamType","ParamTypify","parseParams","allowIndex","splitNesting","Fragment","_isFragment","isFragment","FunctionFragment","EventFragment","ConstructorFragment","trim","split","substring","anonymous","inputs","input","isEventFragment","verifyIdentifier","regexParen","forEach","modifier","warn","parseGas","gas","comps","parseModifiers","constant","payable","stateMutability","console","log","verifyState","payble","toNumber","isConstructorFragment","parens","ouputs","outputs","output","toString","isFunctionFragment","returns","regexIdentifier","accum","depth","offset"],"sources":["../src.ts/fragments.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}